// Generated by CoffeeScript 1.6.2
(function() {
  var EventEmitter, Updown, config, cronJob, exports, mailOptions, mailer, moment, nodemailer, request, timeFormat, util,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  request = require('request');

  global.serviceList = {};

  util = require('util');

  moment = require('moment');

  cronJob = require('cron').CronJob;

  timeFormat = 'MMM D YYYY, h:mm:ss a';

  nodemailer = require("nodemailer");

  mailer = {};

  mailOptions = {};

  config = {
    startPath: '/'
  };

  Updown = function(name, config) {
    this.name = name;
    this.config = config;
    this.config.cronTime = this.config.cronTime || '00 */1 * * * *';
    this.last_run = null;
    this.next_run = null;
    this.countRun = 0;
    this.service_name = name.toLowerCase();
    if (serviceList[this.service_name] != null) {
      throw new Error("Duplicate service name: " + this.name);
    }
    if ((this.config.ping != null) && this.config.ping === true) {
      this.setCronTime('ping');
      this.init();
      this._setServiceTime();
    }
    return this;
  };

  EventEmitter = require("events").EventEmitter;

  exports = module.exports = Updown;

  exports.createService = function(name, config) {
    return new Updown(name, config);
  };

  exports.setPath = function(path) {
    return config.startPath = path;
  };

  exports.middleware = function() {
    var app;

    app = require("./http")(config);
    return app;
  };

  /*
  Inherit from `EventEmitter.prototype`.
  */


  Updown.prototype.__proto__ = EventEmitter.prototype;

  Updown.prototype.init = function() {
    var self;

    self = this;
    this.on('error', function() {});
    serviceList[this.service_name] = this.config;
    serviceList[this.service_name].info = {};
    serviceList[this.service_name].name = this.name.replace(/\s/g, '-');
    serviceList[this.service_name].name_origin = this.name;
    return serviceList[this.service_name].info.interval = this.cronTime.cronTime.getTimeout();
  };

  Updown.prototype.ping = function() {
    var acceptStatusCode, self, url;

    self = this;
    url = this.config.url;
    this._setServiceTime();
    acceptStatusCode = [200, 201, 202, 203, 204];
    return request(url, function(err, res, body) {
      var _ref;

      if (err != null) {
        self.isNotOk();
        return self.emit('error', err);
      } else {
        if (_ref = res.statusCode, __indexOf.call(acceptStatusCode, _ref) >= 0) {
          self.isOk();
          return self.emit('success', res, body);
        } else {
          self.isNotOk();
          return self.emit('error', body);
        }
      }
    });
  };

  Updown.prototype.process = function(fn) {
    var self;

    self = this;
    this.setCronTime('process');
    this.init();
    this.process_fn = fn;
    return this._setServiceTime();
  };

  Updown.prototype.runProcess = function() {
    var done, self;

    self = this;
    this._setServiceTime();
    done = {
      success: function(data) {
        return self.success(data);
      },
      error: function(data) {
        return self.error(data);
      }
    };
    return this.process_fn(done);
  };

  Updown.prototype.setCronTime = function(type) {
    var e, self;

    self = this;
    try {
      return this.cronTime = new cronJob({
        cronTime: self.config.cronTime,
        onTick: function() {
          if (type === 'ping') {
            return self.ping();
          } else if (type === 'process') {
            return self.runProcess();
          } else {
            return thorw(new Error('setCrontime type not valid'));
          }
        },
        start: true
      });
    } catch (_error) {
      e = _error;
      throw new Error('Cron pattern not valid');
    }
  };

  Updown.prototype.error = function(data) {
    return this.isNotOk(data);
  };

  Updown.prototype.success = function(data) {
    return this.isOk(data);
  };

  Updown.prototype.isOk = function(data) {
    if (data == null) {
      data = null;
    }
    serviceList[this.service_name].info.data = data;
    this.state = 'UP';
    serviceList[this.service_name].info.status = 'UP';
    return serviceList[this.service_name].info.interval = this.cronTime.cronTime.getTimeout();
  };

  Updown.prototype.isNotOk = function(data) {
    if (data == null) {
      data = null;
    }
    if (this.state === 'UP' && this.config.sendmail === true) {
      this.sendMail();
    }
    serviceList[this.service_name].info.data = data;
    this.state = 'DOWN';
    serviceList[this.service_name].info.status = 'DOWN';
    return serviceList[this.service_name].info.interval = this.cronTime.cronTime.getTimeout();
  };

  Updown.prototype.sendMail = function() {
    var self;

    self = this;
    mailOptions.subject = "Service [ " + this.name + " ] has down";
    mailOptions.html = "<b>Service Name</b> : " + this.name + " <br>\n<b>Location</b> : " + this.config.url + " <br>\n<b>Check Time</b> : " + (moment().format('LLL'));
    mailer.sendMail(mailOptions, function(error, response) {
      if (error) {
        console.log('Send email error');
        return console.log(error);
      } else {
        return console.log("Email sent: " + self.name + " ");
      }
    });
    return mailer.close();
  };

  Updown.prototype._setServiceTime = function() {
    var interval, last_run, next_run;

    interval = this.cronTime.cronTime.getTimeout() / 1000;
    last_run = moment().format(timeFormat);
    next_run = moment().add('seconds', interval).format(timeFormat);
    if (this.countRun > 0) {
      this.last_run = last_run;
    }
    this.next_run = next_run;
    serviceList[this.service_name].info.last_run = this.last_run;
    serviceList[this.service_name].info.next_run = next_run;
    return this.countRun++;
  };

  exports.mailConfig = function(config) {
    mailer = nodemailer.createTransport("SMTP", config);
    return mailOptions = {
      to: config.to
    };
  };

}).call(this);
